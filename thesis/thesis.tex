%==========================================
%
% Academic thesis template
%
% Based on KOMA-Script book class.
%
% This template is not officially endorsed 
% by any educational institution.
%
% Ben Swift   22/6/12
% benjamin.j.swift@gmail.com
% http://github.com/benswift/thesis-template
%
% This template is in the public domain
%
% Strongly modified by Veit Heller
%
%==========================================
% preamble
\documentclass[oneside,11pt,xetex]{scrbook}
\KOMAoptions{%
  headings=normal,
  captions=rightbeside,
  bibliography=totoc,
  listof=totoc}

%\usepackage{libertineotf}
\usepackage{amsmath}
\newcommand{\argmax}[1]{\underset{#1}{\operatorname{argmax}}}

\usepackage{fontspec}
\setmonofont[Scale=MatchLowercase,Mapping=tex-text]{Tahoma}

\usepackage{booktabs}
\usepackage{tabu}
\usepackage{listings}
\usepackage{minted}
% if you want colour tables
% \usepackage{colortbl}

\usepackage[svgnames,hyperref]{xcolor}

\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\graphicspath{{./figures/}}

\usepackage[margin=10pt,labelfont=bf]{caption}
\usepackage[labelformat=simple]{subcaption}
\renewcommand\thesubfigure{(\alph{subfigure})}

\usepackage{metalogo}
\usepackage{hologo}
\usepackage{verbatim}
\usepackage{setspace}
\usepackage{enumitem}

\newlist{transcriptlist}{description}{1}
\setlist[transcriptlist]{font=\sffamily\bfseries,
                              align=left,
                              leftmargin=1.6cm,
                              labelindent=\parindent, 
                              labelwidth=*}

\newenvironment{transcript}%
{\small\begin{transcriptlist}}%
{\end{transcriptlist}}

\newlist{headinglist}{description}{1}
\setlist[headinglist]{font=\sffamily\bfseries, 
                           leftmargin=0cm,
                           style=nextline}

\usepackage[%
backend=biber,
natbib=true,
backref=true,
citecounter=true,
dashed=false,
backrefstyle=three,
citestyle=authoryear-icomp,
firstinits=true,
maxcitenames=2,
maxbibnames=10,
uniquename=mininit,
bibstyle=authoryear,
url=false,
doi=false]{biblatex}

\AtEveryBibitem{\clearfield{month}}
\AtEveryCitekey{\clearfield{month}}

\nocite{*}
\addbibresource[datatype=bibtex]{thesis.bib}

\usepackage[english=british,threshold=15,thresholdtype=words]{csquotes}
\SetCiteCommand{\parencite}

\newenvironment*{smallquote}
  {\quote\small}
  {\endquote}
\SetBlockEnvironment{smallquote}

\usepackage[%
unicode=true,
hyperindex=true,
bookmarks=true,
pdftitle={Beyond .*Script},
pdfauthor={Veit Heller},
colorlinks=false,
pdfborder=0,
allcolors=DarkBlue,
pdfpagelabels,
hyperfootnotes=true]{hyperref}

\usepackage{bookmark}

\usepackage[%
acronym,
nomain,
toc=true]{glossaries}

\usepackage{cleveref}

\newacronym{ast}{AST}{Abstract Syntax Tree}
\newacronym{html}{HTML}{Hypertext Markup Language}
\newacronym{css}{CSS}{Cascading Stylesheets}
\newacronym{dsl}{DSL}{Domain-Specific Language}
\newacronym{bsd}{BSD}{Berkeley Software Distribution}
\newacronym{zeps}{zeps}{Zepto Package System}
\newacronym{zpr}{ZPR}{Zepto Package Registry}
\newacronym[plural={Scheme Requests For Implementation (SRFIs)}]{srfi}{SRFI}{Scheme Request For Implementation}
\newacronym{pep}{PEP}{Python Enhancement Proposal}
\newacronym{eep}{EEP}{Erlang Enhancement Proposal}
\newacronym{r5rs}{R5RS}{Revised\textsuperscript{5} Report on the Algorithmic Language Scheme}
\newacronym{jit}{JIT}{Just In Time Compiler}
\newacronym{llvm}{LLVM}{Low Level Virtual Machine}
\newacronym{frp}{FRP}{Functional Reactive Programming}
\newacronym{gui}{GUI}{Graphical User Interface}
\newacronym{ir}{IR}{Intermediate Representation}
\newacronym{ghc}{GHC}{Glasgow Haskell Compiler}
\newacronym{repl}{REPL}{Read-Eval-Print Loop}
\newacronym{ffi}{FFI}{Foreign Function Interface}
\newacronym{api}{API}{Application Programming Interface}
\newacronym{dom}{DOM}{Document Object Model}
\newacronym{w3c}{W3C}{World Wide Web Consortium}
\newacronym{yui}{YUI}{Yahoo User Interface Library}

\renewcommand{\thepage}{\roman{page}}

\makeindex
\makeglossaries

\linespread{1.3}

\begin{document}


\title{Beyond .*Script}
\subtitle{Implementing A Language For The Web}

\author{Veit Heller}

\date{\today}

\publishers{%
  \normalsize{%
  A thesis submitted for the degree of \\
  B.Sc. of Applied Computer Science of \\
  The University of Applied Sciences Berlin}}

\uppertitleback{%
  \textbf{Institutional Address}\\
  HTW Berlin\\
  Campus Treskowallee\\
  Treskowallee 8\\
  10318 Berlin\\
  \textsc{Germany}\\
  \bigskip\\
  \textbf{Supervisory Panel}\\

  Prof. Hendrik Gärtner\\
  HTW Berlin\\

  Prof. Henrick Lochmann\\
  Prof. Henrik Lochmann\\
  HTW Berlin\\
  \bigskip\\
  Set with the help of {\KOMAScript} and
  \XeLaTeX.\\

  \copyright~\the\year. All rights reserved.}

\dedication{\small{\emph{For Meredith, Tobias and all the people who cope with me. Your undying support will not be forgotten.}}}

\pdfbookmark{Title Page}{Title Page}
\maketitle

\frontmatter

\vspace*{0.4\textheight}

\begin{center}
  Except where otherwise indicated, this thesis is my own original
  work.
\end{center}
\vspace*{4cm}

\begin{flushright}
  \begin{minipage}{4cm}
    Veit Heller\\
    \today
  \end{minipage}
\end{flushright}

\addchap{Abstract}

This thesis presents and evaluates a port of the zepto programming language to the web. It aims to
work as seamlessly with existing technologies as possible and is largely influenced by \gls{r5rs},
a standard of the Lisp derivative Scheme\footnote{A deeper introduction into \gls{r5rs} can be found
in \ref{sec:ExistingStandards}.}.

It is the result of over a year of independent research on zepto, a new programming language
targetting various environments. The prototype described here and implemented for this
thesis runs on JavaScript, a language found natively in many web browsers.

The central problem addressed by this thesis is the incoporation of a language runtime
into the web ecosystem without the need for extensive code rewrites while supporting
most features of the reference implementation of zepto, including large parts of the
standard library. This also includes interoperability between the two languages.

It is also discussed inhowfar tooling for both JavaScript and zepto, most specifically
their respective package managers, interoperate for building larger scale web applications.

\pdfbookmark{Contents}{Contents}
\tableofcontents

\printglossary[type=\acronymtype,title=Abbreviations]

\mainmatter

\pagestyle{headings}

\setchapterpreamble[u]{%
  \dictum[\emph{B. Kernighan}]{Controlling complexity is the essence of computer programming.}
  \bigskip}
\chapter{Introduction}
\label{chap:intro}

\section{Motivation}
\label{sec:Motivation}

JavaScript has, since its inception, attracted a lot of controversy. This is rooted
in various aspects of its design, from prototypal inheritance and the \gls{dom} to
its operator precedence. Especially prototypal inheritance  has been the root
of a lot of discussions in the Computer Science community. It has the reputation of
being counter-intuitive, though it is older than JavaScript, the first commonly known
programming language that implemented prototypal objects being Self.

This and a few other design choices have prompted many programmers to develop
wrapper libraries around almost anything that comprises the language. The most widely-used
example of this is arguably jQuery, a library that abstracts over the \gls{dom}.
But more arcane topics have been covered as well: there is, for example, the \gls{yui}, a now-abandoned
project of Yahoo that aimed to abstract over web \glspl{api} but also comes with
its own inheritance model. This model likens JavaScript prototypes to classical classes by
introducing special functions and properties to the objects such as \texttt{extend}
and \texttt{superclass}.

All of those libraries have shaped the way JavaScript has developed and in the
upcoming revisions of ECMAScript\footnote{ECMAscript is the officially trademarked
name of what application developers and browser vendors most commonly refer to as
JavaScript.}, ECMAScript 6\footnote{ECMAScript 6 was renamed to ECMAScript 2015
along the way but for the sake of clarity this thesis uses the more commonly
know name of the revision. For an up-to-date version of that revision please
refer to \parencite{ECMA6}.} and ECMAScript 7\footnote{Now ECMAScript 2017. For
an up-to-date version of the current draft please refer to \parencite{ECMA7}.}, a
lot of conveniences from third-party libraries have been adopted by the
"vanilla"\footnote{A common name for JavaScript that refrains from leveraging
paradigm-altering libraries.} JavaScript canon.
Among these features has been the widely controversial introduction of a \texttt{class}
notation for JavaScript that makes prototypes feel more like classes (without
breaking existing semantics).

\subsection{Preprocessors \& Transpilers}
\label{pretrans}

This and other features have been available to JavaScript developers for much
longer than the latest iterations of the JavaScript language without them needing
to rely on a possibly massive library - provided they use a preprocessor.
One of the earliest exemplars of preprocessing for JavaScript, CoffeeScript, included
\texttt{lambdas}, a shorthand for anonymous functions; \texttt{pattern matching},
a technique for destructuring data; and \texttt{classes}, all of which found
their way into the latest ECMAScript revisions.

Preprocessing can serve a lot of different purposes apart from providing
syntactic commodities to the programmer. Babel, for instance, is a relatively
novel library for transpiling JavaScript that adheres to the new standards
of ECMAScript back to older revisions, for the sake of backwards-compatibility.
It also aims to provide small optimizations before the code reaches the compiler,
such as constant hoisting, a compiler optimization technique that eliminates
pure functions that always produce the same result in favour of global constants
to reduce the overhead of function calls.

Transpilation from a different language is another increasingly popular
way to use JavaScript as a platform. One could argue that CoffeScript
is nothing short of a transpiler; but one could also argue against this idea,
considering its only purpose is to compile to JavaScript. Other general-purpose
languages such as Clojure and C++, originally developed to run on other platforms,
have the option to compile to JavaScript through ClojureScript \parencite{CLJS} and
Emscripten \parencite{ZAKA} respectively.

\subsubsection{Caveats}

This thesis was inspired by the work done in the field of transpilation to
JavaScript. Its goal is not to present yet another attempt at transpilation,
but rather to rethink the way languages are incorporated into the web of today.

At their heart, all of the preprocessors and transpilers that target JavaScript
are JavaScript, even if the syntax and semantics differ radically. There needs
to be a clean mapping of the source language to JavaScript. Because of its flexibility,
this is often a doable task, albeit not always desirable.

The value of having the same abstraction present at runtime as at compile-time
is obvious if the language that is consider places strong emphasis on code
mutability, such as in Lisp or Elixir\footnote{As exemplified by Chris McCord in
\parencite{ELIX}.}.

\section{Goals of this Thesis}

The primary goal of this thesis is to present a novel approach at implementing languages
for the Web. This is exemplified by a sample implementation of a non-trivial, pure and
largely feature-complete functional programming language that has been tested
in production systems.

Many reasons would speak for a procedural or objective-oriented language as
a prototype. On one hand, the language itself could be more easily implemented in
JavaScript if it is reasonably close to it. Another point that speaks
against using a functional - and especially pure - programming language is the possibility of
making interoperability harder because JavaScript is intrinsically
impure and stateful.

But all of those reasons could also be read as argument \textit{for} the implementation
of a functional language. The difference showcases JavaScript's ability
to express concepts foreign to the language in it. It also serves as a better
test bench for more advanced implementation patterns.

This is especially true for those features of the base language that are not
present in JavaScript and non-trivial to add to it from a user perspective.
The features present in the target language implemented in this thesis but not
in JavaScript most notably include Macros\footnote{The ability to rewrite
code at parse or compile time, see \ref{macro}.} and Continuations\footnote{The
control state of a program represented as a data structure within the code, see
\ref{continuation}.}. Those features were chosen especially because they are
extremely foreign to JavaScript programming.

\section{Structure of this Thesis}

Chapter 2 examines related work in the field of cross-compilation into JavaScript and implementation
of interpreters that are directly embeddable into larger systems. This includes desktop applications,
game scripting engines and creative suites.

Chapter 3 gives an overview of the concept design and how the features are laid out to match the needs
of both the goals of this thesis and the prototype itself.

Chapter 4 presents the system design and how the prototype integrates into existing web components.

Chapter 5 discusses the implementation, picking out different fundamental parts of the system and
presents how they work.

Chapter 6 evaluates the prototype. This includes problems such as how well the integration of the
system worked and how it compares to the reference implementation of zepto.

Chapter 7 gives a brief summary of what was done and gives an outlook to what might happen with
zepto, both the desktop and the JavaScript version, in the future.

\chapter{Related Work}
\label{chap:RelatedWork}

This section aims to give a quick overview of work that has already been done in the
field of transpilation to and language implementations on top of JavaScript. A few
of the most important specimens have already been mentioned briefly in \ref{pretrans},
although their relationship to this thesis has not yet been discussed.

\section{Existing Projects}

In this section, a brief overview over a short, not necessarily exhaustive list of
transpilers from existing programming languages to and languages explicitly
acting as a layer of abstraction over JavaScript shall be presented.

The aim of this section is not to present the reader with the syntax and semantics
of every single language is discussed, but rather equip them with a general
overview of the ecosystem at the time of writing and how it correlates to the
work presented in this thesis.**cut down?**

\subsection{Transpilers}
\label{trans}

Transpilers are normally defined as compiling one high level language into another.
They are often referred to as cross-compilers, although this term is imperfect as
it also refers to compilation from one hardware platform or operating system to
another.

Due to this ambiguity, the name \textit{transpiler} was chosen to refer to this
kind of system in the context of this thesis.

\subsubsection{GHCJS}
\label{sec:GHCJS}

GHCJS - often hyphenated as GHC-JS - is a transpiler from the Haskell language
to JavaScript. It is currently maintained by Luite Stegeman. It aims to "solve
the JavaScript problem"\footnote{A talk given by Stegeman bore this title, see
\parencite{STEG}.}, in that it enables the user to compile any Haskell program to JavaScript
instead of machine code by the means of inserting a custom compiler backend into
the \gls{ghc} toolchain.**I tend to integrate quotes into a sentence on both sides if they are short like that, but this is a stylistic choice**

GHCJS is the compiler used in this thesis to transpile the existing zepto codebase
to JavaScript. Its plug-and-play design, near-complete implementation of the
Haskell programming langauge, and relative maturity all contributed to the decision
to use it as an implementation language\footnote{Further discussion of the design
and decision process can be found in \ref{chap:ConceptDesign} and
\ref{chap:SystemDesign}.}.

\subsubsection{Emscripten}

Emscripten as discussed in \parencite{ZAKA} aims to be a transpiler from \gls{llvm} to
JavaScript. Its primary focus is the translation of C and C++ source code
to JavaScript.

Emscripten's use case is similar to that of GHC-JS, enabling the user to both "(1)
Compile code directly into LLVM assembly, and then compile that into JavaScript
using Emscripten, or (2) Compile a language’s entire runtime into LLVM and then
JavaScript, as in the previous approach, and then use the compiled runtime to
run code written in that language" (\cite{ZAKA}), the latter of which sounding
suspiciously like what zepto-js tries to achieve. **run-on, think about describing list items in second sentence** There have been efforts to
make the PyPy \gls{jit}\footnote{A \gls{jit} designed to speed up Python programs
by analyzing and compiling them, described in \parencite{PYPY}.} work in the
browser. While this seems to have gained a fair bit of traction and work
reasonably well\footnote{A live demonstration of how it works can be found on
its \href{https://pypyjs.org}{website, accessible under https://pypyjs.org}.},
documentation on it is sparse and there is seemingly no academically viable
source detailing its development and architecture.

\subsubsection{ClojureScript}
\label{sec:ClojureScript}

ClojureScript is a backend for the Clojure programming language that targets
JavaScript. Initially developed by Rich Hickey, the author of Clojure, it is
now maintained under David Nolen's lead \parencite{CLJS}.

Being a Lisp, there are obvious syntactic similarites to zepto. Yet, as it is
transpiled rather than interpreted directly in the browser, programming against
it is quite difficult. Specifically, the way the \gls{ffi} works is quite
different, as ClojureScript has a lot of syntactic integrations that help embed
JavaScript within it. All functions prefixed with a period are assumed to
be JavaScript functions on the prototype of the object provided as first argument.
JavaScript values can be directly accessed through the \texttt{js} namespace.
Zepto's design is quite different, as is discussed in \ref{sec:ffi}.

\begin{listing}[H]
\caption{A comparison of the \gls{ffi} of JavaScript in zepto and ClojureScript.}
\begin{minted}[linenos,frame=single]{clojure}
; ClojureScript provides syntactic abstractions over
; the embedding of foreign code.
(.getElementById js/document "body")

; An equivalent zepto call, with strings
(js "document.getElementById(\"body\")")
; OR, if a variable is accessed
(js (++ "document.getElementById(\"" body "\")"))
\end{minted}
\end{listing}

\subsection{Abstraction Languages}

The languages mentioned here are languages that abstract purely over JavaScript,
choosing it as their primary backend. This differs from the languages discussed
in \ref{trans}, which are general purpose languages with the option to compile
to JavaScript if desired by the developer.

This list is not designed to be exhaustive, but rather aims to inform about
recent developments in web programming.

\subsubsection{CoffeeScript}

As mentioned int \ref{pretrans}, when it first appeared, CoffeeScript was one of the first transpilers that targeted JavaScript.\footnote{The first git commit
dates back to
\href{https://github.com/jashkenas/coffeescript/commit/8e9d637985d2dc9b44922076ad54ffef7fa8e9c2}{December 13th, 2009}.
The first public release happened shortly after that.}. Many of the constructs, both relating to syntax and semantics
have been adopted by JavaScript.
CoffeeScript is similar to JavaScript in that it is a procedural, prototypal
language. No semantic features have been added or removed from JavaScript,
making it relatively dissimilar to the programming system presented in this
thesis.

\subsubsection{Elm}

Elm as it is presented in \parencite{CPL} is a language centered around
\gls{frp}\footnote{An in-depth explanation of \gls{frp} is outside of
the scope of this thesis, but it is a programming style \parencite{FRP}.}
with a special regard to browser-based \glspl{gui}. Formulated by Paul Hudak
and Conal Elliott in a 1997 paper, it borrows
its syntax largely from Haskell and is a pure, functional programming
language. Notable features include \gls{gui}-centric tooling, such
as a "time-traveling" debugger that caches the state of a program
at any given time, allowing for rewinding, forwarding and jumping.

Elm's sole similarity to the language discussed in this thesis is that it is
a functional language for the Web. However, it compiles to JavaScript, \gls{html}
and \gls{css}, once again falling short of actually getting the code to the
browser. It is also very centered around the aforementioned \gls{frp},
whereas the runtime presented in this thesis aims to be a general-purpose
programming environment.**this paragraph could be beautified: add some fluidity**

\subsubsection{PureScript}

PureScript is, much like Elm, a functional, pure programming language
that borrows a lot of its syntax from Haskell. It aims to compile into
human-readable JavaScript and make general purpose programming for the web
in a strongly typed, functional style possible.

It is different from GHCJS insofar as it does not provide compatibility
with Haskell code, although many libraries and functions are relatively
similar. See \ref{fig:ps} for an example.

As it shares a lot of features with Elm, it also largely shares the
differences to the system presented in this thesis.

\begin{listing}[H]
\caption{A juxtaposition of a simple function in Haskell and PureScript.}
\begin{minted}[linenos,frame=single]{haskell}
-- | Extract the first element of a list (as implemented in the language standard library).
-- | The Haskell version is unsafe and will throw an error
-- | if it encounters an empty list.
head :: [a] -> a
head (x:_) =  x
head [] =  badHead -- an exception function

-- | the list data type in PureScript is safe by design and
-- | the function returns a Maybe monad.
head :: forall a. List a -> Maybe a
head Nil = Nothing
head (Cons x _) = Just x
\end{minted}
\end{listing}
\label{fig:ps}

\section{Existing Standards}
\label{sec:ExistingStandards}

When developing a programming language derived from the Lisp family, one builds on
top of almost 70 years of development, formalization, and research. Of course
many of the standards formed during this time are now obsolete.
Nonetheless, the effort of standardizing the many languages and implementations
is still thriving. **strengthen transition sentence**

Over the years, two main categories of languages have developed: Common Lisp
and Scheme. While the syntactic proximity remains, the categories differ widely in
concepts. \ref{fig:lispcomp} shows the differences between those language families.

Zepto is a Scheme derivative loosely based on \gls{r5rs} \parencite{R5RS}, the most
widely implemented standard of Scheme. It draws from a lot of standard library
functions, syntax definitions and continuations, but aims to introduce custom namespaces
to provide a cleaner, more modular way of defining software libraries\footnote{This module
system will be explained in \ref{chap:ConceptDesign} in depth.}.

The reason why a Scheme derivative was chosen over an implementation of Common Lisp can be
found in the feature set; hygienic macros and continuations are valuable abstractions that
guarantee that components work together more seamlessly. An example of code that works as
expected in Scheme but not in Common Lisp can be found in \ref{fig:schemevscomlisp}. **make this a footnote** It
implements a simple – if a bit contrived – version of binary \texttt{or} in Common Lisp and
in Scheme. In Common Lisp, the variables defined in regular code will potentially be
shadowed by the ones generated during macro expansion where in Scheme they reside in
different contexts and thus are hygienic. This makes the system more intuitive and eliminates
a class of potential bugs, making it more desirable.

While \gls{r5rs} is certainly a valuable standard and provided a lot of very useful information
for the development for zepto, the language is not as closely tied to the standard as most other
implementations. This allowed for the development of zepto-js to progress relatively unencumbered
by incompatibilities, although one goal of the development effort was not to break any existing
syntactic or semantic ties with \gls{r5rs}, as this might potentially have broken a big part of
the standard library, one of the major arguments for zepto as a language. **run-on sentence, suggested rewrite: This allowed for the development of zepto-js to progress mostly unencumbered by incompatibilities, although one goal of the development effort was not to break any existing syntactic or semantic ties with \gls{r5rs}. Breaking these links could potentially have broken a big part of the standard library, with the library being one of the major arguments for zepto's existence as a language. *Feel free to edit this more so that it jives technically, but it most definitely needs to be multiple sentences.** 

\begin{center}
\begin{figure}
  \begin{tabu}{| l | l | l | l | l | l |}
  \hline
  \rowfont{\footnotesize}
              & Macro Keyword & Macro Dispatch   & Hygienic Macros & Continuations & Standard\\ \hline
  \rowfont{\footnotesize}
  Scheme      & define-syntax & pattern matching & present         & present       & ANSI Common Lisp\\ \hline
  \rowfont{\footnotesize}
  Common Lisp & defmacro      & argument passing & not present     & not present   & RNRS\\ \hline
  \end{tabu}
  \caption{A comparison between Common Lisp and Scheme}
\end{figure}
\label{fig:lispcomp}
\end{center}

\subsection{\glspl{srfi}}

An important argument for adhering to the \gls{r5rs} standard are \glspl{srfi}. They are standard
library enhancement proposals from the Scheme programmer community that propose implementations through
the additions of features, much like \glspl{pep} for the Python programming languages and \glspl{eep}
for Erlang. **still awkward, reword** However, the differences that set the former apart from the latter two is the inclusion
of a reference implementation\footnote{This is not required, but part of the "good tone" of the community
and \gls{srfi}s lacking them are relatively rare.}.**subject-verb agreement error** Zepto currently supports five of these requests by default,
one of which implements a core feature of the language: descriptive custom data types.

In the past, the relative ease of porting the implementation of these requests was a major convenience. By moving even farther away from the Scheme standards, this process would
undoubtedly be affected in a negative manner. **add specific consequences** Thus, for both the reference implementation and its
JavaScript equivalent, it was decided that a core set of primitives must be available under all circumstances
to allow for the cross-fertilization of Scheme and zepto. **rethink passive voice here "it was decided"**

\begin{listing}[H]
\caption{Common Lisp Macros vs. Scheme Macros}
\begin{minted}[]{scheme}
; the Common Lisp version
(defmacro my-or (x y)
  `(let ((tmp x))
    (if tmp
      x
      y)))

(my-or #f #t)
; works (yields true), expands to:
(let ((tmp #f)) (if #f #f #t))

(let ((tmp #t))
  (my-or #f #t))
; does not work (yields false), expands to:
(let ((tmp #t)) ((tmp #f)) (if #f #f tmp))

; the Scheme version
; it will work as expected in both versions
(define-syntax
  (syntax-rules
    ((my-or x y)
      (let ((tmp x))
        (if tmp
          x
          y)))))
\end{minted}
\end{listing}

\subsection{Unix}

While not necessarily a standard, Unix and its guidelines do affect zepto in an indirect way as much of zeptos
tooling, such as the \gls{zeps} are using Unix utilities and system calls internally. This is expected to change
in the future, but so far all the developers that have worked on or with zepto\footnote{At least to the knowledge
of the author.} have used Unix or Unix-like systems such as MacOS X or \gls{bsd}. This is less of a problem in the
browser context because many of the packaging and versioning tools are run from the command line before the application
is distributed, but it is important to keep in mind that some of the tools rely on a specific Operating System when
developing zepto programs.

\setchapterpreamble[u]{%
  \dictum[\emph{T. Peters}---The Zen of Python]{Practicality beats purity.}
  \bigskip}
\chapter{Concept Design}
\label{chap:ConceptDesign}

The concept of a version of zepto that would run on JavaScript arose rather
naturally from the work done on zepto as a backend-agnostic, run-everywhere
concept language. Concurrently to the work on a nanopass compiler that
targets \gls{llvm} and Erlang but supports pluggable backends by design, efforts
have been made to bring the language into the browser setting. After preliminary
work on a compiler backend that emits JavaScript that was discarded in the
early stages of its development for the reasons stated in \ref{sec:Motivation},
the idea presented in this thesis emerged.

In the following, a brief overview of the design of the concepts used
in the port and how they impacted the construction of the system shall be
given. A system-based design overview shall be given in \ref{chap:SystemDesign}.

\section{Construction Design}
\label{sec:ConstructionDesign}

The value of integrating zepto into existing web infrastructure lies in
the addition of a host of new features that are not present natively in
JavaScript and hard to implement in a stable manner\footnote{While stability
is not guaranteed by the current version of zepto, it is tested and deployed
in production systems and shows to function rather reliably.}.**Make sentence
into two or eliminate clauses; restructure to eliminate intro** The goal of
the prototype was thus to expose all of the features that define zepto in
the JavaScript implementation as well.

A brief overview over why a Lisp was chosen for this thesis and, more specifically,
why zepto, shall be given in the following.

\subsection{Lisp}

A common saying among programming language designers is that every programmer has written
their own implementation of Lisp.\footnote{The README of the femtolisp project even goes so
far to claim "Some programmers' dogs and cats probably have their own lisp implementations
as well." \parencite{BEZL}.} There are a lot of different implementations of Lisp
in the wild, even ones that compile to JavaScript, such as ClojureScript, the
backend for Clojure referenced in \ref{sec:ClojureScript}.

The simplicity of the language on a parsing level is often cited as the main reason for
its popularity as a language to implement.
A simple Lisp can be implemented in less than one hundred lines of code if no
intermediate representation is generated. This is made possible by the unique property
of Lisp of enclosing every statement in parentheses, where the first element within
those parentheses is the statement name and the other elements are the arguments.
It can be evaluated straight from a textual level, because things such as operator precedence
and statement amiguity do not exist. In regular Lisp as specified in the initial paper by
John McCarthy \parencite{JCM} only a handful special forms exist to allow not only for
Turing-completeness, but also for expressiveness and elegance.

\subsection{zepto}

As explained in \ref{sec:ExistingStandards}, Zepto is a new Scheme implementation that aims
to be as small as possible, to be able to target a lot of different backends and simplify the
process of writing new backend code. Currently, \gls{llvm} and Erlang Core\footnote{Erlang Core 
is the \gls{ir} of Erlang code before it is complied. Resources and documentation
about it are sparse, it mostly seems to exist inside the BEAM's implementation. A small
paper \parencite{ERL} that describes its' basics was used to implement the compiler from
zepto.} bindings are under development, the reference implementation is a simple interpreter
that interprets code directly from the \gls{ast}. This is slow but ensures a small
interpreter size\footnote{The entire codebase is only about 4000 lines of Haskell code.}.
The compilers are written directly in zepto itself.

The small code base makes zepto a good target for porting it to the web. Further, because it
is written in Haskell the code base was expected to be possibly almost entirely compilable
to JavaScript using GHCJS, the transpiler mentioned in \ref{sec:GHCJS}, a backend
for the \gls{ghc} targetting JavaScript instead of native code. It offers many advanced
compilation features such as inlining of JavaScript into the Haskell code
base using a technique called quasi-quoting, where a special character sequence delimits the
inlined code, much like regular quotes. This tool set was expected to make the work of porting
an existing language to the web as simple as possible.

Of course there are other reasons to use a functional language as an example for how to
bring a language into the browser. With both syntax
and semantics differing strongly from JavaScript, this example enables languages more
closely related to JavaScript to eventually make their way into the browser.

\subsection{Macros}
\label{macro}

Macros are a mechanism for rewriting code at compilation time. As discussed in
\ref{sec:ExistingStandards}, zepto's macros are hygienic, which prevents name collisions
with code at runtime and eliminates a class of particularly nasty bugs. Macros are
evaluated in a step between the parser and the actual runnig or compilation of code
called macro expansion, where they rewrite parts of the source code that reference
it according to its specifications.

Because Scheme macros leverage pattern matching and argument overloading by default,
they allow for syntactic extensions of the language. An example for a simple yet
interesting case is made in \ref{fig:listcomp}, where a simple syntactic rule set
for list comprehensions is defined, not unlike a \gls{dsl}, albeit a very small one.
This particular list comprehension is syntactically close to the same construct in
Haskell, although the semantics should be relatively clear at a close inspection and
are, for the sake of example, a bit simple than in the language it is inspired by.

\begin{listing}[H]
\caption{Defining \& using a macro in zepto}
\begin{minted}[]{scheme}
; this defines a macro of the name listcomp
(define-syntax listcomp ; the name
  (syntax-rules (<- |) ; the set of rules and special tokens to respect
    ((_ expr | elem <- elems) ; the pattern to match where
                                   ; the underscore character is a wildcard
      (map (lambda (elem) expr) elems)))) ; the pattern is simply rewritten to a call to the map function

; add1 to every x in the list
(listcomp (add1 x) | x <- [1 2 3 4]) ; => [2 3 4 5]
(listcomp (add1 x) | x <- (range 4)) ; => [1 2 3 4]
\end{minted}
\end{listing}
\label{fig:listcomp}

It should be noted that zepto supports list comprehensions by default and they are
both a bit more concise and more powerful - as they allow for the filtering of
elements from the source list - than the version defined here.

\subsection{Continuations}
\label{continuation}

Continuations are a datatype representing the state of a program at the time of
request, including environments, definitions and execution path. By manipulating
it and injecting it into different contexts, it becomes a powerful tool to switch
back and forth between multiple threads of execution, without actually creating
or managing threads. A practical application of coroutines was for instance
presented in \parencite{COR}, where it was used to implement a fully formed
coroutine system that was capable of starting, stopping and pausing execution
of multiple coroutines at once without the need for actual threading.

An exhaustive explanation of continuations cannot possibly be given in the scope
of this thesis, for further information about this concept refer to \parencite{CONT}.

\section{Additional Features}

There are features in zepto that are not present in Scheme as specified by \gls{r5rs}, such
as the module system and the extensive standard library. In this section, a brief list of
the features and libraries that discriminate zepto from "regular" Scheme shall be given.

\subsection{The module system}

Zepto implements a custom module system that is completely defined in terms of the language
itself. A small code example of different actions in zepto's module space are given in \ref{fig:zepmod}.
This allows for namespaced, conditional and renaming imports, a feature missing from standard
Scheme\footnote{Although the upcoming R7RS standard will most likely include such a mechanism.}.
This approach has a few upsides that all boil down to the module system being available in the
user namespace; monkey-pacthing and mocking objects is possible very easily, easing for instance
testing and fixing flaws in the program at runtime. It is also relatively small and simple,
at about 130 lines of macro-backed code, which makes it fairly maintainable.

However, this approach comes not without its drawbacks. Most notably, relying on a module
system that works at runtime requires more complex compilation and a dispatch system to
be present while the program is running. It also requires global data in the form of a
special variable \texttt{*modules*} holding the mapping of names to values, a concept that is
unusual for a functional programming language and might hinder the compilation into other
representations. Of course global data is also normally either not thread-safe or relatively
slow to use if it requires some sort of synchronization mechanism - which is currently not
a feature that zepto implements.

It has been decided that this is an acceptable tradeoff for zepto as it currently stands,
but the system might be changed in the future.

\begin{listing}[H]
\caption{Defining \& using a zepto module}
\begin{minted}[]{scheme}
; this defines a module of the name "mathematics"
(module "mathematics"
  (export
    `("add" ,add)
    `("substract" ,substract)
    `("multiply" ,multiply))

  ; the actual worker function (not exposed)
  ; applies a function to a list of arguments
  (doop (op args)
    (apply op args))

  ; the exported functions; essentially just wrappers
  ; around doop
  (add (lambda arguments (doop + arguments)))
  (substract (lambda arguments (doop - arguments)))
  (multiply (lambda arguments (doop * arguments))))

; will return a reference to the function
(import "mathematics:add")
; so that it can be bound to a name
(define add (import "mathematics:add"))
; or called directly
((import "mathematics:add") 1 2)

; import all under the namespace "mathematics"
(import-all "mathematics")
; import all under the namespace "mt"
(import-all "mathematics" "mt")
\end{minted}
\end{listing}
\label{fig:zepmod}

For the case of JavaScript, this part of zepto's implementation proved not
to be a problem and worked without further tweaking.

\subsection{The standard library}

Zepto comes with a fairly extensive standard library that includes a wide
variety of utilities spanning such diverse topics as cryptography\footnote{As found
in the \texttt{rsa} module, which implements RSA key generation, signing,
validating and en- and decryption.}, testing, monads, parsing command line
arguments and a parser combinator. An exhaustive list of the modules found
in the zepto standard library at the time of writing can be found in \ref{app:stdlib}.

This is fairly unusual for Scheme implementations insofar as many of them
come with a fairly minimalistic set of libraries that is often largely based
on SRFIs exclusively. Two notable exceptions are Chibi Scheme\footnote{The source
code for Chibi Scheme and its standard library can be found on Github under
https://github.com/ashinn/chibi-scheme.}, and Racket, the distributions of which
are bundled with an even bigger standard library. This might be due to the fact
that Alex Shinn, the main developer behind Chibi Scheme, is very active in the
Scheme community and authored a few SRFIs of his own and Racket is a language
supported by the Computer Science faculties of multiple universities  and is
the result of over 20 years of research.

The stability of the libraries that come bundled with zepto varies and is not
ensured until the reference implementation reaches version 1.0.0. However, many
of these libraries have at least been used by other libraries in the zepto
ecosystem and are thus the subject of continuous scrutiny.

The standard library as a concept in zepto is thought to be a rather minimal,
but usable set of primitives to get the developer started. Once they feel
comfortable in the programming environment, it is suggested they start working
with \gls{zeps}.

\subsection{\gls{zeps}}

\gls{zeps} is the package manager for zepto. It is capable of installing and
managing packages from Github and the \gls{zpr} through the command line. It
is undoubitably the biggest coherent piece of code written entirely in zepto
and it is capable of intalling and updating itself. At the time of writing,
at least 40 packages have been published with \gls{zeps}, including a framework
for writing web servers and a Redis database client. It is only able to run
on Unix-like systems or systems exposing at least a Unix-like shell.

The authentication system of \gls{zeps} on the \gls{zpr} is RSA-backed, which
also allows for the signing of packages for the user's convenience. This feature
is not available when installing from Github.

The package system aims to be a cohesive, intuitive entity for installing,
removing, creating, managing, testing and updating packages\footnote{A list of
all the available commands is given in \ref{app:zepscmds}.}. It includes
facilities for creating sandboxed environments, making dependency management
of multiple systems with possibly conflicting dependency trees possible.
It can also be used to distribute zepto-based command line tools and its
ability to bootstrap packages is scriptable, allowing for plugins to
decide what files should be generated on the creation of a new package.

It has proved to be useful in workshops and user feedback sessions to make
sure all of the attendees can easily manage their first projects.

\setchapterpreamble[u]{%
  \dictum[\emph{T. Peters}---The Zen of Python]{Practicality beats purity.}
  \bigskip}
\chapter{System Design}
\label{chap:SystemDesign}

The prototype described in this thesis, while from a programming language
implementation standpoint very close to the reference implementation of
zepto, required a few modifications to the way it integrates with its'
environment.

Zepto as an interpreter is a closed-off program that does not interact
with its surroundings save for program input. Zepto-js on the other hand
has to integrate with technologies and \glspl{api} to make programming
a web application not only possible, but also convenient. A solid model of
interaction had to be found as a consequence.

\section{Integration into the Web Ecosystem}

To make zepto-js fit into the web and its components, a few design decisions
for the interpreter startup had to be done. Rather than make it \gls{repl} and
file-based as in the reference implementation, a tag-based approach was pursued.
This ensures that programming in zepto-js would not differ drastically from
programming in JavaScript from the viewpoint of an application\footnote{An example
of those tags is given in \ref{fig:zpjs}.}.

There are multiple ways to implement this interface. An initial design idea was to
bundle a zepto executable in the form of a browser extension that would parse the
\gls{html} code on the page. This would not require the user to download a big JavaScript
file every time they visit a page that leverages zepto-js. With the ubiquity of
smart caching mechanisms in modern browsers it is, however, unclear how big of
a gain this would be. On the other hand it would limit the userbase of the website
to the setof people who have the extension installed, a major drawback for possible
language users.

It was thus determined that he prerequisite for being able to embed zepto code into
a website should be to include the zepto-js distribution in the website. To make
this more attractive, zepto-js can be loaded asynchronously onto the web page as it
is required to also work if the \gls{dom} was already built. An explanation of how
zepto is loaded and identifies the tags it should interpret is given in \ref{sec:MutObs}.

\begin{listing}[H]
\caption{The interface of zepto-js within a \gls{html} page.}
\begin{minted}[linenos,frame=single]{html}
<script type="text/zepto">
  (define (fact n) "a tail-recursive version of the factorial function"
      (define (internal acc n)
        (if (<= n 0)
          acc
          (internal (* acc n) (sub1 n))))
      (internal 1 n))
</script>
<script type="text/zepto">
\end{minted}
\end{listing}
\label{fig:zpjs}

\subsection{Integration with Web \glspl{api}}

**TODO**

\subsection{Integration with build tools}

A big part of modern web development is the availability of tools that automate
the process of shipping JavaScript code. There are tools that cross-compile, minify
and optimize JavaScript in a matter of seconds\footnote{A few of those tools have been
mentioned in the chapters \ref{sec:Motivation} and \ref{chap:RelatedWork}.}. There are
also utilities that simplify the definition of pipelines in which the code is passed
through various of those tools for greater composability, such as Grunt or Gulp.

These tools can be used to write zepto-js-backed websites as well. While many of
the optimizations, minifications and cross-compilers become unusable once the switch
from JavaScript to another language is made, the facilities of those tools to collect
and merge multiple source files, for instance, can be used without bigger modifications.
Furthermore, as those tools are agnostic not only to the types of files they deal with
but also to the types of tools they are to run on the source files, zepto-js-specific
optimizers can be run on those files should they emerge.

Many of the preprocessed languages discussed in \ref{chap:RelatedWork} use these
technologies to compile their source files to JavaScript before shipping them.
While zepto-js has no regular \gls{api} that can be plugged into those build tools
at the moment, a simple integration with existing tasks is possible as shown in
\ref{fig:gulp}.

\begin{listing}[H]
\caption{A gulp task that collects and merges zepto files.}
\begin{minted}[linenos,frame=single]{javascript}
'use strict';

var gulp   = require('gulp');
var concat = require('gulp-concat');

global.buildEnv = 'development';

gulp.task('bundle', function(){
  // Process scripts
  var files = "zepto/*.zp";
  gulp.src(files)
      .pipe(concat('app.zp'))
      .pipe(gulp.dest('build'))
});
// == Register default task
gulp.task('default', ['bundle'], function() {
});
\end{minted}
\end{listing}
\label{fig:gulp}

\setchapterpreamble[u]{%
  \dictum[\emph{Hofstadter’s Law}]{It always takes longer than you expect, even when you take into account Hofstadter’s Law.}
  \bigskip}
\chapter{Implementation}
\label{chap:Implementation}

The implementation philosophy of the port presented in this thesis has always been to
reuse as much code from the reference implementation as possible. This guided the flow of design
choices down a rather natural path and kept the implementation described here fairly short and trivial.

\section{Description of the Toolchain}

The tooling uses GHCJS, which is a backend for the \gls{ghc} compiler that targets JavaScript rather
than native code (TODO: remove this from introduction). This makes cross-compiling the code base to
JavaScript a rather simple undertaking.

GHCJS offers many advanced features such as inlining of JavaScript into the code
base using a technique called quasi-quoting, in which a special character sequence delimits the
inlined code, much like regular quotes. This tool set was expected to simplify rewriting the code
bits that needed adjustment.**verb tense: does it no longer simplify rewriting code?**

The management of pure JavaScript sources is another important feature. GHCJS provides management
of these sources akin to the management of bits of C code that should interface with Haskell in a
regular \gls{ghc} project.**wordy** The build file includes a segment called \texttt{js-sources}, which ensures
that the JavaScript in those sources will be included in the final compilation. The informal convention
seems to be to put the files that should be included into a directory called \texttt{jsbits} (a hat-tip
to the \gls{ghc} convention of putting C sources into cbits).

The code emitted by GHCJS is conservative in feature use. This is an important feature if older clients
with possibly even obsolete browsers want to access web pages supported by zepto code, rare as they might
be.**wordy**

All these conveniences do not spare the programmer from the actual programming process, of course.
While GHCJS seems like a well-maintained project one has to keep in mind that it is not backed
by a consortium as \gls{ghc} is, and the current maintainer seems to do this work completely
in his spare time. This gives users the impression that the project could be abandoned at any given
moment. Therefore, being too dependent upon its more unusual features could lead to a product that
is unnecessarily difficult to maintain.

Taking all of this into consideration, a preliminary analysis revealed two main conditions for
the success of this thesis: 1) the code emitted by FHCJS is fast, solid, and reasonably compact,
and 2) the newest features of both JavaScript and Haskell were supported\footnote{The newest version
of \gls{ghc} at the time of writing, version 8.0, gained support while this thesis was in the works.}.

\section{Description of the Implementation}

As predicted in \ref{sec:Motivation}, the code base of zepto could be reused almost in its entirety.
What had to be rewritten was mostly related to the startup of the interpreter, because the regular
paths into the code - either via a script being passed into it or launching an interactive
\gls{repl}\footnote{A \gls{repl} is an interactive code evaluation environment. Code is typed into
a prompt and immediately evaluated. The convenience of such a short feedback loop is often used
in the context of scripting languages and shells.} - were unavailable in the browser context.
Instead, a way of passing the sources from within \texttt{script} tags needed to be found. Further
customizations include a \gls{ffi} to enable better cross-evaluation of JavaScript and the adaptation
of existing \gls{api}s, such as the \gls{dom}.

\subsection{The \texttt{script} tag}
\label{sec:MutObs}

Initially, a \gls{dom} node walker was considered, but rejected relatively early because of two reasons:
firstly, it introduced a layer of complexity from within JavaScript code that would have likely made
it brittle and hardly portable. Secondly, it would require a walk of the nodes every time a \gls{dom}
element is inserted or replaced, which is a common occurence in modern interactive web applications.

In November 2015, the \gls{w3c} released **word choice?** an \gls{api} that simplified this process
for the programmer. Within their specification of the
\href{https://www.w3.org/TR/dom/#mutationobserver}{DOM4} \parencite{DOM4} , the fourth
specification of \gls{api}s for the Web, an object called \texttt{MutationObserver} is included which
is able to register for \gls{dom} manipulations. Its main function will be triggered whenever a change
occurs within the \gls{dom} part, to which it is registered to listen. **rephrase as you wish, but to should not be at the end of the sentence**

This simplifies the implementation of a listener to DOM events a great deal. Only minimal programming
is required to configure the listener and to filter out all the nodes that are not \texttt{script} nodes
of the type \texttt{text/zepto}\footnote{This was chosen in analogy to the existing \texttt{text/javascript}
node type.}.

A problem left ignored with this method was that nodes inserted before the listener started.**awkward, rephrase** This was resolved by
singling out all the \texttt{script} tags present before the listener starts and applying the
same filter/evaluation function to all of them.**verb tenses** This also ensures that they are executed before any
additional code (and possibly dependent) is passed into the zepto object.

The code was then included in the \texttt{zepto} singleton, which is the global interpreter object
used for the management and interactivity of the zepto interpreter.

\begin{listing}[H]
\caption{The final mutation observer code (simplified)}
\begin{minted}[]{javascript}
// the initial observer and the function it takes
zepto.observer = new MutationObserver(zepto.handleMutation);

// this function will get a list of mutations and apply handleDom to them
zepto.handleMutation = function(mutations) {
  mutations.forEach(mutation => {
    mutation.addedNodes.map(zepto.handleDom);
  });
}

// evaluate if it is a text/zepto node
zepto.handleDom = function(node) {
  if (node.nodeName != "SCRIPT" || node.type != "text/zepto") {
    return null;
  }
  return zepto.eval(node.innerHTML);
}

// execute this on startup
window.onload = () => {
  let scripts = document.getElementsByTagName("script");
  scripts.map(zepto.handleDom);
}
// the extra arguments signify recursive listening
zepto.observer.observe(document, {childList: true, subtree: true});
\end{minted}
\end{listing}

\subsection{The \gls{ffi}}
\label{sec:ffi}

The \gls{ffi} is a central part of the port. If it were unusable, none of the browser's
capabilities could be used from within zepto, thus rendering the effort of bringing zepto into
the browser effectively useless. The \gls{api}s of the Web are a big part of what it means to
program for the browser, after all.

An initial sketch of the programming interface was extremely simplistic: a call to the
function \texttt{js} could be called with a string as argument, representing the textual
representation of the JavaScript program that should be run. It was piped to the JavaScript
function \texttt{eval} and the function returned an affirmative truth value. Quasi-quoting
larger blocks of JavaScript was also possible.

Of course this is unusable. **word choice, see above** The missing return value makes any effort of talking to an
\gls{api} impossible, as one could never yield any results.**rephrase clause 2** A different kind of return
value is needed.

The most obvious solution – albeit the most challenging – would be to infer a fitting zepto type
for every return value in JavaScript and return a result depending on these paramaters. While
this could be seen as a rather elegant solution, it comes with its own set of caveats
and exceptions, as the mapping between JavaScript and zepto values is not always obvious.
A JavaScript object has too many properties that get lost in the process of translating
it to zepto as to make it intuitive.

\begin{listing}[H]
\caption{The ideal FFI}
\begin{minted}[]{clojure}
; this would return an integer
(js "1 + 1")

; this would return a hashmap
(js "{key: \"val\""})

; this is problematic, because it will return an object
(js "new Error()")
\end{minted}
\end{listing}

The implementation of JavaScript values in GHCJS is another point of complication. They
are opaque datatypes, aliases for addresses and byte vectors. While zepto supports
byte vectors and pointers, they are hardly a good representation for semantically rich
prototypes as they only offer a glance into the underlying implementation of the
JavaScript engine. While it is true that GHCJS itself provides methods for type
coercion, these methods are crude and possibly error-prone.

A simpler method but still mostly sensible arose: returning the string
values of all of the values returned. While this places the burden of coercion
on the programmer, it also gives them the power to make their own 
decisions of how to deserialize values. Functions for deserializing the most
common datatypes are included in the standard library of the JavaScript
implementation of zepto, to aid the programmer in the process of finding
the right methods of getting a value out of the \gls{ffi}.

This still does not solve the problem of helping manage classes. It does, though, empower
the programmer to find their own ways of serializing on the JavaScript side
and deserializing on the zepto side to preserve the information they need in
their specific programming context.

All of this needs an additional layer of abstraction to avoid unnecessary
boilerplate, but it is stable enough for most purposes that zepto in JavaScript
was used for yet.

\begin{listing}[H]
\caption{The final form of the FFI}
\begin{minted}[]{clojure}
; the function string->number is a standard zepto function
(string->number (js "Math.pow(2, 32)"))

; this is an example of how to resolve the earlier problem:
; override the prototype of the object to return the value that is needed
(js "Error.prototype.toString = function() { return this.message; }")
(error (js "new Error(\"fatal error occured\")"))
\end{minted}
\end{listing}

Implementing the JavaScript to zepto \gls{ffi} was much simpler, as the
interpreter is defined within the JavaScript environment. A call to the
\texttt{eval} function of the \texttt{zepto} object with a string as argument
will return in the execution of this piece of code and the return the textual
representation of the zepto object so that the entire communication between
the languages is string-based.**rephrase; missing verb? make two sentences w/ break after "piece of code".**

\subsection{The \gls{dom}}

After building the \gls{ffi}, it was possible to implement the entire
communication with the \gls{dom} in terms of calls to foreign functions
and the parsing of their return values. This allows for a stable library,
because it is unintrusive and does not interfer with existing JavaScript
constructs.

Existing zepto-js projects often find it convenient to write a hybrid mix
of JavaScript and zepto code that calls each other at certain points.
This is, however, probably not advisable at the layer of libraries or
utilities, because it is at risk of getting in the way of the job.

\begin{listing}[H]
\caption{A minimal DOM module}
\begin{minted}[]{clojure}
(module "dom"
  (export
    `("create" ,create)
    `("insert" ,insert)
    `("get" ,get))

  (loads "html")

  (update-dom! (lambda (node contents)
    (js (++ "document.getElementById('" node "').innerHTML = '"
            (create contents)
            "';"))))

  (create (lambda (tree)
    ((import "html:build") tree)))

  (insert (lambda (context tree)
      (update-dom! context tree)))

  (get (lambda (node)
    ((import "html:parse")
       (js (++ "document.getElementById('" node "');"))))))
\end{minted}
\end{listing}

\subsection{Language definitions}

One of the most advanced features is language definitions, inspired by
the parser macro system in Racket \parencite{RPM}. While this is handled
fairly differently in zepto than in Racket, the syntax of the resulting
language is compatible. Zepto handles the custom parser step with a dispatch
at the time of file loading, which enabled the system to be implemented without
changes to the core language, completely in zepto itself. While this was 
designed with portability in mind and thought to ease the transition to
different backends, it actually proved to complicate matters in the case
of the JavaScript port. Here, the module loading system is not present due
to the absence of files in the traditional sense.

\begin{listing}[H]
\caption{An example language definition that allows for inlining of JSON code.}
\begin{minted}[]{clojure}
; json-lang.zp
(load "json/json")

(zepto:implements-lang json:parse "json")

; an example for a file that can now be normally loaded
#lang json
{
  "hello": "json"
}
\end{minted}
\end{listing}

As the detection of what to parse is handled from within JavaScript - by the
MutationObserver mentioned in \ref{sec:MutObs} - the first implementation
of the dispatch mechanism was written entirely in JavaScript. This proved
to make the dispatch mechanism relatively clumsy, because registering
additional languages had to be done in JavaScript, making this feature
a JavaScript rather than a zepto feature. While building a parser dispatch
mechanism for JavaScript would certainly also make for an interesting experiment,
it is out of the scope of this thesis and would not really qualify as something
unique about zepto\footnote{The code was salvaged for posteriority and can be
found on \href{https://github.com/hellerve/js-parse-dispatch}{Github under the
name of \texttt{js-parse-dispatch}}.}.

**TODO**

\setchapterpreamble[u]{%
  \dictum[\emph{R. Buckminster Fuller}]{When I'm working on a problem, I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.}
  \bigskip}
\chapter{Evaluation of the Prototype}
\label{chap:evaluation}

**TODO**

\section{Seamlessness of Integration}

\section{Test Against Standard Implementation of Zepto}

* added: ffi

* removed load statement, REPL functionality, language definitions

* inserting libraries?

\setchapterpreamble[u]{%
  \dictum[\emph{Isaac Asimov}]{Part of the inhumanity of the computer is that, once it is competently programmed and working smoothly, it is completely honest.}
  \bigskip}
\chapter{Summary and Outlook}
\label{chap:outlook}

The prototype presented in this thesis was never expected to be a replacement
for technologies that are currently making the web what it is. It is a simple
experiment that happens to work well enough to power less than a handful
actual production systems, a blessing for the development of zepto. The
use cases provided real insight into the descripancy of how the program
works and how it should work. It is also a liability going forward, as users
do not generally appreciate breaking changes.

The software system certainly proved that it is possible to make other
languages work on the web, an idea that is nasceant but, by the hopes of
those involved in the production of zepto-js, one that might become a trend
going forward.

Other developments in the zepto ecosystem are just as exciting. There have
been efforts to port zepto to a few different platforms, all of which are
far from finished, but interesting to follow along nonetheless. The compiler
and parser have both gained languages, some of them usable - the aforementioned
compiler backends for LLVM and Erlang come to mind, and the web server framework
that uses a \gls{dsl} to simplify writing request handlers - , some of them born
purely out of the desire to toy around with the language - parsers and cross-compilers
for a handful of esoteric programming languages have been written, including Brainfuck,
Io and Iota.

The development of \gls{zeps} has surely contributed to the growth of zepto and
it has fueled the development of zepto-js. It is tested on real systems and has
withstood the scrutiny of colleagues and contributors. By the definition of the
development team, however, it is not yet ready for a big public release, hence
the timid version number of 0.0.7. The road to go might be not as long as this
number suggests, but it certainly is long enough to merit a healthy dose of
defensiveness.

Another big development in the zepto community has certainly been a series of
classes and workshops. They, too, helped route the development of zepto down
a path of usability, self-awareness and constant reevaluation. Targetted at an
audience of diverse people with mostly little to no experience with functional
programming or Lisp, they have shown to not only wake an interest in those concepts
but also led to the development of a few projects for zepto and its' JavaScript-backed
counterpart that now have become part of the standard toolset, such as the plugins for
the Atom and Vim plugins.

In regard to tooling for zepto-js, a newly formed development team comprised of
people experienced in web development is building plugins for zepto-js to integrate
with Gulp\footnote{One of the tools mentioned in \ref{sec:IntegrationTooling}.} for
such tasks as minification and dependency resolution. Integration of \gls{zeps} with
Gulp is a subject for the near future, too.

All of these developments start to hint at a community in its nascence. It might
be too quick to judge whether this is true, but it would certainly be a welcome
development for zepto and its maintainers.

\chapter{Conclusion}
\label{chap:conclusion}

There have been voices that insisted that the web need be fixed
since its inception. Most disagreements over its inner workings
have been philosophical and are a matter of ongoing dispute.
While the web certainly can be improved - like any system,
at any time - I do not believe it is fundamentally flawed. The
technologies that power the current World Wide Web, from switches
and cable technologies to protocols and development frameworks,
have shown to be robust enough for a large part of the world
to interconnect. We steadily adapt the way we work with it
as trends and paradigms emerge and evolve.

One of the major redeeming qualities of the fundamental
philosophies of the World Wide Web has certainly been
its ability to adapt to changes. Standardization of web
technologies has a reputation of being slow, but in terms
of design processes on a global scale, it is actually a
reasonably fast process.

Zepto is a young language that has adapted this mindset -
changes rapidly and a stable release is yet to be announced.
With this thesis, an important step towards reaching a fulfillment
of its design goals has been made.

Many questions that this thesis has addressed remain unanswered.
Even with that in mind, I hope that my work on it has asked
questions that are worth being asked and that the technologies
presented in this thesis will allow for more technologies that
come to the web, so that an even more heterogeneous,
expressive and inclusive system can emerge, one that
caters to different aesthetics, philosophies and mindsets.

I would happily welcome any contributions towards that
end, both related to and unencumbered by the technology
that is zepto.


%============================================
%============================================
% end matter

\appendix

\chapter{List of Modules in the Zepto Standard Library}
\label{app:stdlib}

Libraries that are loaded by default are denoted by \textit{(dflt.)}.

\begin{description}
\item [argparse] A command line argument parser
\item [ascii] An ASCII art modul
\item [bench] A simple benchmarking and timing library
\item [calculus] A library that implements combinators of the lambda calculus
\item [char\textit{(dflt.)}] A library of functions for working with characters
\item [cl] A library that exports standard Common Lisp functions
\item [data] A library that exports lazy data types, such as queues, deques and streams
\item [datetime] A library for working with and formatting dates and times
\item [delay\textit{(dflt.)}] A utility library for delaying computations
\item [infix] A library that translates infix mathematical expressions to the appropriate
prefix form
\item [io\textit{(dflt.)}] A library of functions for Input and Output
\item [json] A JSON parser and renderer
\item [keywords\textit{(dflt.)}] A library that allows for keyword arguments as found in Python
\item [marsaglia] A library of functions for cryptographically strong Pseudo-Random Number Generators
\item [math\textit{(dflt.)}] A library of functions for mathematical purposes
\item [minitest] A testing library
\item [module\textit{(dflt.)}] Zepto's module system
\item [monads] A library of monads and monadic computations
\item [parsecomb] A parser combinator library
\item [pointfree] A library for defining functions in point-free style
\item [querystring] A querystring parser and renderer
\item [random\textit{(dflt.)}] A library of functions for cryptographically insecure random number
and data generation
\item [rsa] A RSA library
\item [slugify] A library for generations slugs
\item [sort\textit{(dflt.)}] A sorting library
\item [srfi\textit{(dflt.)}] A library of SRFIs
\item [statistics] A statistics library
\item [struct\textit{(dflt.)}] A library for generating structs with the appropriate functions
declaratively
\item [zpbash] A BASH library
\item [zpcllections\textit{(dflt.)}] A library of functions for defining and working with collections
\item [zpcont\textit{(dflt.)}] A library of functions for working with continuations
\item [zpconversion\textit{(dflt.)}] A library of functions for converting between datatypes
\item [zperror\textit{(dflt.)}] A library of functions for working with errors
\item [zpfile\textit{(dflt.)}] A library of functions for working with files
\item [zpgenerics\textit{(dflt.)}] A library of functions for defining and working with
generic functions
\item [zphash\textit{(dflt.)}] A library of functions for working with hash maps
\item [zplist\textit{(dflt.)}] A library of functions for working with lists
\item [zpnumbers\textit{(dflt.)}] A library of functions for working with numerical values
\item [zpstring\textit{(dflt.)}] A library of functions for working with strings
\item [zpvector\textit{(dflt.)}] A library of functions for working with vector
\item [zpversion\textit{(dflt.)}] A library of functions for working with the current zepto version
\end{description}

\chapter{List of \gls{zeps} commands}
\label{app:zepscmds}

This list can also be found in the README of zeps under
\texttt{https://github.com/zeps-system/zeps}.

\begin{description}
\item [test] Runs the module tests.
\item [t] shortcut for test.
\item [search] Search for packages matching a search term (on the ZPR).
\item [sandbox] Create/destroy a sandboxed zeps environment
\item [run] Run the module entry-point, without installing it
\item [repl] Launches an interactive shell with a certain module preloaded.
\item [remove] Removes a package.
\item [rm] shortcut for remove.
\item [register] Registers a package.
\item [r] shortcut for register.
\item [new] Bootstraps a new package.
\item [n] Shortcut for new.
\item [keygen] Generates a new RSA key for zeps.
\item [install] Installs a package.
\item [i] Shortcut for install.
\item [help] Interactive help on getting started
\item [readme] Prints zeps' README
\end{description}

\backmatter

\bookmarksetup{startatroot}

\printbibliography[title=References,heading=bibintoc]

\end{document}
