%==========================================
%
% Academic thesis template
%
% Based on KOMA-Script book class.
%
% This template is not officially endorsed 
% by any educational institution.
%
% Ben Swift   22/6/12
% benjamin.j.swift@gmail.com
% http://github.com/benswift/thesis-template
% 
% This template is in the public domain
% 
%==========================================
% preamble
\documentclass[oneside,11pt,xetex]{scrbook}
\KOMAoptions{%
  headings=normal,
  captions=rightbeside,
  bibliography=totoc,
  listof=totoc}

%\usepackage{libertineotf}
\usepackage{amsmath}
\newcommand{\argmax}[1]{\underset{#1}{\operatorname{argmax}}}

\usepackage{fontspec}
\setmonofont[Scale=MatchLowercase,Mapping=tex-text]{Tahoma}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{minted}
% if you want colour tables
% \usepackage{colortbl}

\usepackage[svgnames,hyperref]{xcolor}

\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\graphicspath{{./figures/}}

\usepackage[margin=10pt,labelfont=bf]{caption}
\usepackage[labelformat=simple]{subcaption}
\renewcommand\thesubfigure{(\alph{subfigure})}

\usepackage{metalogo}
\usepackage{hologo}
\usepackage{verbatim}
\usepackage{setspace}
\usepackage{enumitem}

\newlist{transcriptlist}{description}{1}
\setlist[transcriptlist]{font=\sffamily\bfseries,
                              align=left,
                              leftmargin=1.6cm,
                              labelindent=\parindent, 
                              labelwidth=*}

\newenvironment{transcript}%
{\small\begin{transcriptlist}}%
{\end{transcriptlist}}

\newlist{headinglist}{description}{1}
\setlist[headinglist]{font=\sffamily\bfseries, 
                           leftmargin=0cm,
                           style=nextline}

\usepackage[%
backend=biber,
natbib=true,
backref=true,
citecounter=true,
dashed=false,
backrefstyle=three,
citestyle=authoryear-icomp,
firstinits=true,
maxcitenames=2,
maxbibnames=10,
uniquename=mininit,
bibstyle=authoryear,
url=false,
doi=false]{biblatex}

\AtEveryBibitem{\clearfield{month}}
\AtEveryCitekey{\clearfield{month}}

\nocite{*}
\addbibresource[datatype=bibtex]{thesis.bib}

\usepackage[english=british,threshold=15,thresholdtype=words]{csquotes}
\SetCiteCommand{\parencite}

\newenvironment*{smallquote}
  {\quote\small}
  {\endquote}
\SetBlockEnvironment{smallquote}

\usepackage[%
unicode=true,
hyperindex=true,
bookmarks=true,
pdftitle={Beyond .*Script},
pdfauthor={Veit Heller},
colorlinks=false,
pdfborder=0,
allcolors=DarkBlue,
pdfpagelabels,
hyperfootnotes=true]{hyperref}

\usepackage{bookmark}

\usepackage[%
acronym,
nomain,
toc=true]{glossaries}

\usepackage{cleveref}

\newacronym{ast}{AST}{Abstract Syntax Tree}
\newacronym{ir}{IR}{Intermediate Representation}
\newacronym{ghc}{GHC}{Glasgow Haskell Compiler}
\newacronym{repl}{REPL}{Read-Eval-Print Loop}
\newacronym{ffi}{FFI}{Foreign Function Interface}
\newacronym{api}{API}{Application Programming Interface}
\newacronym{dom}{DOM}{Document Object Model}
\newacronym{w3c}{W3C}{World Wide Web Consortium}
\newacronym{yui}{YUI}{Yahoo User Interface Library}

\renewcommand{\thepage}{\roman{page}}

\makeindex
\makeglossaries

\linespread{1.3}

\begin{document}


\title{Beyond .*Script}
\subtitle{Implementing A Language For The Web}

\author{Veit Heller}

\date{\today}

\publishers{%
  \normalsize{%
  A thesis submitted for the degree of \\
  B.Sc. of Applied Computer Science of \\
  The University of Applied Sciences Berlin}}

\uppertitleback{%
  \textbf{Institutional Address}\\
  HTW Berlin\\
  Campus Treskowallee\\
  Treskowallee 8\\
  10318 Berlin\\
  \textsc{Germany}\\
  \bigskip\\
  \textbf{Supervisory Panel}\\

  Prof. Hendrik GÃ¤rtner\\
  HTW Berlin\\

  Prof. Henrick Lochmann\\
  Prof. Henrik Lochmann\\
  HTW Berlin\\
  \bigskip\\
  Set with the help of {\KOMAScript} and
  \XeLaTeX.\\

  \copyright~\the\year. All rights reserved.}

\dedication{\small{\emph{For Meredith, Tobias and all the people who cope with me. Your undying support will not be forgotten.}}}

\pdfbookmark{Title Page}{Title Page}
\maketitle

\frontmatter

\vspace*{0.4\textheight}

\begin{center}
  Except where otherwise indicated, this thesis is my own original
  work.
\end{center}
\vspace*{4cm}

\begin{flushright}
  \begin{minipage}{4cm}
    Veit Heller\\
    \today
  \end{minipage}
\end{flushright}

\addchap{Abstract}

This thesis presents and evaluates a port of the zepto programming language to the web. It aims to
work as seamlessly with existing technologies as possible and is largely influenced by R5RS,
a standard of the Lisp derivative Scheme.

It is the result of over a year of independent research on zepto, a new programming language
targetting various environments. The prototype described here and implemented for this
thesis runs on JavaScript, a language found natively in many web browsers.

The central problem addressed by this thesis is the incoporation of a language runtime
into the web ecosystem without the need for extensive code rewrites while supporting
most features of the reference implementation of zepto, including large parts of the
standard library. This also includes interoperability between the two languages.

It is also discussed inhowfar tooling for both JavaScript and zepto, most specifically
their respective package managers, interoperate for building larger scale web applications.

\pdfbookmark{Contents}{Contents}
\tableofcontents

\printglossary[type=\acronymtype,title=Abbreviations]

\mainmatter

\pagestyle{headings}

\setchapterpreamble[u]{%
  \dictum[\emph{B. Kernighan}]{Controlling complexity is the essence of computer programming.}
  \bigskip}
\chapter{Introduction}
\label{chap:intro}

\section{Motivation}
\label{sec:Motivation}

JavaScript has, since its inception, attracted a lot of controversy. This is rooted
in various aspects of its design, from prototypal inheritance and the \gls{dom} to
itsoperator precedence. Especially prototypal inheritance  has been the root
of a lot of discussions in the Computer Science community. It has the reputation of
being counter-intuitive, though it is older than JavaScript, the first commonly known
programming language that implemented prototypal objects being Self.

This and a few other design choices have prompted many programmers to develop
wrapper libraries around almost anything that comprises the language, the arguably
most widely used example being jQuery, a library that abstracts over the \gls{dom}.
But more arcane topics have been covered as well: there is the \gls{yui}, a now abandoned
project of Yahoo that aims to abstract over web \glspl{api} as well but also comes with
its own inheritance model, likening JavaScript prototypes to classical classes by
introducing special functions and properties to the objects such as \texttt{extend}
and \texttt{superclass}.

All of those libraries have shaped the way JavaScript has developed and in the
upcoming revisions of ECMAScript\footnote{ECMAscript is the officially trademarked
name of what application developers and browser vendors most commonly refer to as
JavaScript.}, ECMAScript 6\footnote{ECMAScript 6 was renamed to ECMAScript 2015
along the way but for the sake of clarity this thesis uses the more commonly
know name of the revision. For an up-to-date version of that revision please
refer to \parencite{ECMA6}.} and ECMAScript 7\footnote{Now ECMAScript 2017. For
an up-to-date version of the current draft please refer to \parencite{ECMA7}.}, a
lot of conveniences from third-party libraries have been adopted by the
"vanilla"\footnote{A common name for JavaScript that refrains from leveraging
paradigm-altering libraries.} JavaScript canon.
Among these features has been the widely controversial introduction of a \texttt{class}
notation for JavaScript that makes prototypes feel more like classes (without
breaking existing semantics).

\subsection{Preprocessors}

This and other features have been available to JavaScript developers for much
longer than the latest iterations of the JavaScript language and without
the need to rely on a possibly massive library - provided they use a preprocessor.
One of the earliest exemplars of preprocessing for JavaScript, CoffeeScript, included
\texttt{lambdas}, a shorthand for anonymous functions; \texttt{pattern matching},
a technique for destructuring data; and \texttt{classes}, all of which found
their way into the latest ECMAScript revisions.

Preprocessing can serve a lot of different purposes apart from providing
syntactic commodities to the programmer. Babel, for instance, is a relatively
novel library for transpiling JavaScript that adheres to the new standards
of ECMAScript back to older revisions, for the sake of backwards-compatibility.
It also aims to provide small optimizations before the code reaches the compiler,
such as constant hoisting, a compiler optimization technique that eliminates
pure functions that always produce the same result in favour of global constants
to reduce the overhead of function calls.

\subsubsection{Caveats} % do we really want to go as deep?

**STUB: TODO**

At its' heart, all of the preprocessors and transpilers that target JavaScript
are JavaScript, even if the syntax and semantics differ radically. This makes
for an interesting case, because it might hinder the web itself from evolving:
at its' core, there is one technology only.

Obviously, a lot of research is going into the development of JavaScript and
it's tools and it might be ignorant to dismiss JavaScript tooling outright,
though. Among transpiler writers, JavaScript is hailed as the assembly of the web.

\section{Goals of this Thesis}

The primary goal of this thesis is to present a novel approach at implementing languages
for the Web. This is exemplified by a sample implementation of a non-trivial, pure and
largely feature-complete functional programming language that has been tested
in production systems.

Many reasons would speak for a procedural or objective-oriented language as
a prototype. For one, the language itself could be more easily expressed in
terms of JavaScript if it is reasonably close to it. Another point that speaks
against using a functional - and especially pure - programming language is that
this might make the interoperability harder because JavaScript is intrinsically
impure and stateful.

But all of those reasons could also be read as argument for the implementation
of a functional language. The difference showcases the ability of JavaScript
to express concepts foreign to the language in it. It also serves as a better
test bench for more advanced implementation patterns.

This is especially true for those features of the base language that are not
present in JavaScript and non-trivial to add to it from a user perspective.
The features present in the target language implemented in this thesis but not
in JavaScript most notably include Macros\footnote{The ability to rewrite
code at parse or compile time, see \ref{macro}.} and Continuations\footnote{The
control state of a program represented as a data structure within the code, see
\ref{continuation}.}. Those features were chosen especially because they are
extremely foreign to JavaScript programming.

\section{Structure of this Thesis}

Chapter 2 examines related work in the field of cross-compilation into JavaScript and implementation
of interpreters that are directly embeddable into larger systems. This includes desktop applications,
game scripting engines and creative suites.

Chapter 3 gives an overview of the concept design and how the features are laid out to match the needs
of both the goals of this thesis and the prototype itself.

Chapter 4 presents the system design and how the prototype integrates into existing web components.

Chapter 5 discusses the implementation, picking out different fundamental parts of the system and
presents how they work.

Chapter 6 evaluates the prototype. This includes problems such as how well the integration of the
system worked and how it compares to the reference implementation of zepto.

Chapter 7 gives a brief summary of what was done and gives an outlook to what might happen with
zepto, both the desktop and the JavaScript version, in the future.

\chapter{Related Work}
\label{chap:RelatedWork}

This sections aims to give a quick overview of work that has already been done in the
field of transpilation to and language implementations on top of JavaScript.

\section{Existing Projects}

\section{Existing Standards}


\setchapterpreamble[u]{%
  \dictum[\emph{T. Peters}---The Zen of Python]{Practicality beats purity.}
  \bigskip}
\chapter{Concept Design}

\section{Construction Design}

\label{chap:ConceptDesign}

NOTE: This had to be moved from chapter 2 to match the current design of the thesis. Please
excuse the lack of coherence.

\subsection{Lisp}

A common saying among programming language designers is that every programmer has written
their own implementation of Lisp. There are a lot of different implementations of Lisp
in the wild, even ones that compile to JavaScript\footnote{such as \href{https://github.com/clojure/clojurescript}{ClojureScript},
a backend of the Clojure compiler that targets JavaScript.}.

The main reason for that is often cited to be the simplicity of the language on a parsing
level. A simple Lisp can be implemented in less than one hundred lines of code, if no
intermediate representation is generated. This is made possible by the unique property
of Lisp of enclosing every statement in parentheses, where the first element within
those parentheses is the statement name and the other elements are the arguments.
It can be evaluated straight from a textual level, because things such as operator precedence
and statement amiguity do not exist. In regular Lisp as specified in the initial paper by
John McCarthy\parencite{JCM} only six special forms exist to allow not only for Turing-completeness,
but also for expressiveness.

\subsection{zepto}

Zepto is a new Scheme implementation that aims to be as small as possible, to be able
to target a lot of different backends. Currently, LLVM and Erlang Core\footnote{Erlang Core 
is the \gls{ir} of Erlang code before it is complied. Resources and documentation
about it are sparse, it mostly seems to exist inside the BEAM's implementation. A small
paper\parencite{ERL} that describes its' basics was used to implement the compiler from
zepto.} bindings are under development, the reference implementation is a simple interpreter
that interprets code directly from the \gls{ast}. This is slow but ensures a small
interpreter size\footnote{The entire codebase is only about 4000 lines of Haskell code.}.
The compilers are written directly in zepto itself.

The small code base makes zepto a good target for porting it to the web. Further, because it
is written in Haskell the code base was expected to be possibly almost entirely compilable
to JavaScript using GHC-JS, a backend for the \gls{ghc} targetting JavaScript instead of
native code. It offers many advanced features such as inlining of JavaScript into the code
base using a technique called quasi-quoting, where a special character sequence delimits the
inlined code, much like regular quotes. This tool set was expected to make the work of porting
an existing language to the web as simple as possible.

Of course there are other reasons to use a functional language as an example. With both syntax
and semantics differing strongly from JavaScript, this example makes way for languages more
closely related to JavaScript also making their eventual way into the browser.

\subsection{Macros}
\label{macro}
\subsection{continuations}
\label{continuation}

\section{Additional Features}


\setchapterpreamble[u]{%
  \dictum[\emph{T. Peters}---The Zen of Python]{Practicality beats purity.}
  \bigskip}
\chapter{System Design}
\label{chap:System Design}

\section{Integration into the Web Ecosystem}


\setchapterpreamble[u]{%
  \dictum[\emph{Hofstadterâs Law}]{It always takes longer than you expect, even when you take into account Hofstadterâs Law.}
  \bigskip}
\chapter{Implementation}
\label{chap:Implementation}

The implementation philosophy philosophy of the port presented in this thesis has always been to
reuse as much code from the reference implementation as possible. This guided the flow of design
choises down a rather natural path and thus kept the implementation described here fairly short and
relatively trivial.

\section{Description of the Toolchain}

The tooling uses GHCJS, which is a backend for the \gls{ghc} compiler that targets JavaScript rather
than native code (TODO: remove this from introduction). This makes cross-compiling the code base to
JavaScript a rather simple undertaking.

GHCJS offers many advanced features such as inlining of JavaScript into the code
base using a technique called quasi-quoting, where a special character sequence delimits the
inlined code, much like regular quotes. This tool set was expected to simplify rewriting the code
bits that needed adjustment.

Another important feature was the management of pure JavaScript sources. GHCJS provides management
of these sources akin to the management of bits of C code that should interface with Haskell in a
regular \gls{ghc} project. The build file includes a segment called \texttt{js-sources} which ensures
that the JavaScript in those sources will be included in the final compilation. The informal convention
seems to be to put the files that should be included into a directory called \texttt{jsbits} (a hat-tip
to the \gls{ghc} convention of putting C sources into cbits).

The code emitted by GHCJS is conservative in feature use. This is an important feature if older clients
with possibly even obsolete browsers want to access web pages supported by zepto code, rare as they might
be.

All these conveniences do not spare the programmer from the actual programming process, of course,
and while GHCJS seems like a well-maintained project one has to keep in mind that it is not backed
by a consortium as \gls{ghc} is and the current maintainer seems to do this work seemingly completely
in his spare time. This leaves us with the notion that the projectm could be abandoned at any point
and being too dependent on its' more unusual features could lead to a product that is unnecessarily
hard to maintain.

All of this considered, a preliminary analysis revealed that the two main conditions for the success
of this thesis were given: the code emitted by GHCJS is fast, solid and reasonably compact and the
newest features of both JavaScript and Haskell were supported\footnote{The newest version of \gls{ghc}
at the time of writing, version 8.0, gained support while this thesis was in the works.}.

\section{Description of the Implementation}

As predicted in \ref{sec:Motivation}, the code base of zepto could be reused in almost its' entirety.
What had to be rewritten was mostly related to the startup of the interpreter, because the regular
paths into the code - either via a script being passed into it or launching an interactive
\gls{repl}\footnote{A \gls{repl} is an interactive code evaluation environment. Code is typed into
a prompt and immediately evaluated. The convenience of such a short feedback loop is often used
in the context of scripting languages and shells.} - were unavailable in the browser context.
Instead, a way of passing the sources from within \texttt{script} tags needed to be found. Further
customizations include a \gls{ffi} to enable better cross-evaluation of JavaScript and the adaptation
of existing \gls{api}s, such as the \gls{dom}.

\subsection{The \texttt{script} tag}

Initially, a \gls{dom} node walker was considered, but rejected relatively early because of two reasons:
Firstly, it introduced a layer of complexity from within JavaScript code that would have likely made
it brittle and hardly portable. Secondly, it would require a walk of the nodes every time a \gls{dom}
element is inserted or replaced, which is a common occurence in modern interactive web applications.

As of November of 2015, the \gls{w3c} specifies an \gls{api} that simplifies this process for the programmer.
Within their specification of the \href{https://www.w3.org/TR/dom/#mutationobserver}{DOM4}\parencite{DOM4}, the fourth
specification of \gls{api}s for the Web, an object called \texttt{MutationObserver} is included which
is able to register for \gls{dom} manipulations. Its main function will be triggered whenever a change
occurs within the \gls{dom} part that it registered for listening to.

This simplifies the implementation of a listener to DOM events a great deal. Only minimal programming
is required to configure the listener and to filter out all the nodes that are not \texttt{script} nodes
of the type \texttt{text/zepto}\footnote{This was chosen in analogy to the existing \texttt{text/javascript}
node type.}.

A problem untended to with that method was nodes insert before the listener starts. This was resolved by
singling out all the \texttt{script} tags that are present before the listener starts and applying the
same filter/evaluation function to all of them. This also ensures that they are executed before any
additional code (and possibly dependent) is passed into the zepto object.

The code was then included in the \texttt{zepto} singleton, which is the global interpreter object
used for the management and interactivity of the zepto interpreter.

\begin{listing}[H]
\caption{The final mutation observer code (simplified)}
\begin{minted}[linenos,frame=single]{javascript}
// the initial observer and the function it takes
zepto.observer = new MutationObserver(zepto.handleMutation);

// this function will get a list of mutations and apply handleDom to them
zepto.handleMutation = function(mutations) {
  mutations.forEach(mutation => {
    mutation.addedNodes.map(zepto.handleDom);
  });
}

// evaluate if it is a text/zepto node
zepto.handleDom = function(node) {
  if (node.nodeName != "SCRIPT" || node.type != "text/zepto") {
    return null;
  }
  return zepto.eval(node.innerHTML);
}

// execute this on startup
window.onload = () => {
  let scripts = document.getElementsByTagName("script");
  scripts.map(zepto.handleDom);
}
// the extra arguments signify recursive listening
zepto.observer.observe(document, {childList: true, subtree: true});
\end{minted}
\end{listing}

\subsection{The \gls{ffi}}

The \gls{ffi} is a central part of the port. If it weren't usable, none of the browser's
capabilities could be used from within zepto, thus rendering the effort of bringing zepto into
the browser effectively useless. The \gls{api}s of the Web are a big part of what it means to
program for the browser, after all.

An initial sketch of the programming interface was extremely simplistic: a call to the
function \texttt{js} could be called with a string as argument, representing the textual
representation of the JavaScript program that should be run. It was piped to the JavaScript
function \texttt{eval} and the function returned an affirmative truth value. Quasi-quoting
larger blocks of JavaScript was also possible.

Of course this is unusable. The missing return value makes any effort of talking to an
\gls{api} impossible, as one could never yield any results. A different kind of return
value is needed.

The obvious but most challenging to implement solution would be to infer a fitting zepto
type for every return value in JavaScript and return a result depending on that. While
this could be seen as a rather elegant solution, it comes with its own set of caveats
and exceptions, as the mapping between JavaScript and zepto values is not always obvious.
A JavaScript object has too many properties that get lost in the process of translating
it to zepto as to make it intuitive.

\begin{listing}[H]
\caption{The ideal FFI}
\begin{minted}[linenos,frame=single]{clojure}
; this would return an integer
(js "1 + 1")

; this would return a hashmap
(js "{key: \"val\""})

; this is problematic, because it will return an object
(js "new Error()")
\end{minted}
\end{listing}

Another problematic point is the implementation of JavaScript values in GHCJS. They
are opaque datatypes, aliases for addresses and byte vectors. While zepto supports
byte vectors and pointers, they are hardly a good representation for semantically rich
prototypes as they only offer a glance into the underlying implementation of the
JavaScript engine. While it is true that GHCJS itself provides methods for type
coercion, they are crude and possibly error-prone.

A simpler method that is still mostly sensible came up: returning the string
values of all of the values returned. While this places the burden of coercion
into the programmer's hand, it also gives them the power to make their own 
decisions of how to deserialize values. Functions for deserializing the most
common datatypes are included in the standard library of the JavaScript
implementation of zepto, to aid the programmer in the process of finding
the right methods of getting a value out of the \gls{ffi}.

This still does not solve the problem of helping manage classes, but it empowers
the programmer to find their own ways of serializing on the JavaScript side
and deserializing on the zepto side to preserve the information they need in
their specific programming context.

All of this needs an additional layer of abstraction to avoid unnecessary
boiler plate, but it is stable enough for most purposes that zepto in JavaScript
was used for yet.

\begin{listing}[H]
\caption{The final form of the FFI}
\begin{minted}[linenos,frame=single]{clojure}
; the function string->number is a standard zepto function
(string->number (js "Math.pow(2, 32)"))

; this is an example of how to resolve the earlier problem:
; override the prototype of the object to return the value that is needed
(js "Error.prototype.toString = function() { return this.message; }")
(error (js "new Error(\"fatal error occured\")"))
\end{minted}
\end{listing}

Implementing the JavaScript to zepto \gls{ffi} was much simpler, as the
interpreter is defined within the JavaScript environment. A call to the
\texttt{eval} function of the \texttt{zepto} object with a string as argument
will return in the execution of this piece of code and the return the textual
representation of the zepto object so that the entire communication between
the languages is string-based.

\subsection{The \gls{dom}}

After building the \gls{ffi}, it was possible to implement the entire
communication with the \gls{dom} in terms of calls to foreign functions
and the parsing of their return values. This allows for a stable library,
because it is unintrusive and does not interfer with existing JavaScript
constructs.

Existing zepto-js projects often find it convenient to write a hybrid mix
of JavaScript and zepto code that calls each other at certain points.
This is, however, probably not advisable at the layer of libraries or
utilities, because it is at risk of getting in the way of the job.

\begin{listing}[H]
\caption{A minimal DOM module}
\begin{minted}[linenos,frame=single]{clojure}
(module "dom"
  (export
    `("create" ,create)
    `("insert" ,insert)
    `("get" ,get))

  (loads "html")

  (update-dom! (lambda (node contents)
    (js (++ "document.getElementById('" node "').innerHTML = '"
            (create contents)
            "';"))))

  (create (lambda (tree)
    ((import "html:build") tree)))

  (insert (lambda (context tree)
      (update-dom! context tree)))

  (get (lambda (node)
    ((import "html:parse")
       (js (++ "document.getElementById('" node "');"))))))
\end{minted}
\end{listing}

\clearpage

\setchapterpreamble[u]{%
  \dictum[\emph{R. Buckminster Fuller}]{When I'm working on a problem, I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.}
  \bigskip}
\chapter{Evaluation of the Prototype}
\label{chap:evaluation}

\section{Seamlessness of Integration}

\section{Test Against Standard Implementation of Zepto}

* added: ffi

* removed load statement, REPL functionality

* inserting libraries?

\setchapterpreamble[u]{%
  \dictum[\emph{R. Buckminster Fuller}]{When I'm working on a problem, I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.}
  \bigskip}
\chapter{Summary and Outlook}
\label{chap:outlook}

* porting efforts

* compiler efforts

* zeps

* classes

\chapter{Conclusion}
\label{chap:conclusion}

* fixing the web not necessary

* rethinking it possible


%============================================
%============================================
% end matter

\backmatter

\bookmarksetup{startatroot}

\printbibliography[title=References,heading=bibintoc]

\end{document}
